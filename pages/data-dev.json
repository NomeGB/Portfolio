{
    "_readme": {
        "description": "Portfolio data file. One JSON per section page. The HTML reads this file automatically via the DATA_URL variable.",
        "fields": {
            "title":    "Big title shown on hero and sticky header",
            "subtitle": "Small text shown below the title on load",
            "tags":     "Array of filter tags. Always keep 'All' as the first one.",
            "items":    "Array of portfolio pieces shown as tiles in the grid"
        },
        "item_fields": {
            "name":     "Title of the piece, shown on tile hover and in the viewer",
            "tags":     "Array of tags for this piece. Must match values defined in the top-level tags array",
            "subtitle": "Small text shown only inside the viewer (e.g. engine, year)",
            "large":    "Optional. Set to true to make the tile span 2 columns",
            "thumb":    "Path to the thumbnail image shown in the grid tile",
            "content":  "Array of content blocks shown inside the viewer, in the order you define them"
        },
        "content_block_types": {
            "image":   "{ type: 'image', src: 'path/to/image.jpg' }  — displays a full-width image",
            "video":   "{ type: 'video', src: 'path/to/video.mp4' }  — displays a video player",
            "text":    "{ type: 'text',  value: 'Your text here...' } — paragraph of descriptive text",
            "spacer":  "{ type: 'spacer', size: 'sm' | 'md' | 'lg' } — vertical blank space between blocks",
            "divider": "{ type: 'divider' }                           — thin horizontal line separator"
        },
        "notes": [
            "You can mix and combine as many content blocks as you want inside each item",
            "The first image or video in content is used as thumbnail if 'thumb' is not set",
            "Supported image formats: jpg, png, webp, gif",
            "Supported video formats: mp4, webm",
            "To create a new section page, duplicate portfolio-page.html and change DATA_URL to point to this file"
        ]
    },

    "title":    "GAME DEVELOPEMENT",
    "subtitle": "Programming · Game design · Rendering",
    "tags": ["All", "Programming", "Rendering", "Game design"],

    "items": [
        {
            "name":     "Deep core",
            "tags":     ["Programming", "Game design"],
            "subtitle": "Personal multiplayer project · 2025",
            "large":    false,
            "thumb":    "./Assets/Media/deepcoret.png",
            "content": [
                { "type": "text",   "value": "My purpose for starting this personal project was to test and practice multiplayer features, as well as test upgradeable and tier mechanics." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/deepcore01.mp4" },
                { "type": "text",   "value": "I present some of the basic mechanics in this video (the video only shows one player, but all mechanics work in multiplayer)." },
                { "type": "text",   "value": "-Basic interact system, hand animations are pose-based so they're easier to change depending on what item you're holding." },
                { "type": "text",   "value": "-Player stats, you can change damage, velocity, or range." },
                { "type": "text",   "value": "-Different pickaxe tiers that change damage, skin, and animations." },
                { "type": "text",   "value": "-Minerals which can have different 'tiers' and slightly different durability values between them." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/deepcore02.mp4" },
                { "type": "text",   "value": "Showcase of a basic procedural map generation system; it lets you choose an amount of hallways/rooms you want for that generation." }
            ]
        },
        {
            "name":     "Generic bodycam project",
            "tags":     ["Programming"],
            "subtitle": "Bodycam test project · 2026",
            "large":    false,
            "thumb":    "./Assets/Media/bodycam.png",
            "content": [
                { "type": "text",   "value": "This project started mostly because of my curiosity of seeing what kind of result I could get doing this kind of camera effects + what kind of non-generic mechanics I could fit into it to make it a little more fun." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/bodycam01.mp4" },
                { "type": "text",   "value": "This is the base i started working with, it's a basic player movement with the only extras of the zoom system and the well-known bodycam effect." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/bodycam02.mp4" },
                { "type": "text",   "value": "I started adding an interact system; I wanted it to feel different than other bodycam games, so I decided to add a UI element (the square in the center) that points wherever the player is pointing. If it finds an interactable object, it will adapt to the size/position of the actual object and display some information about it." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/bodycam03.mp4" },
                { "type": "video",  "src": "./Assets/Media/bodycam04.mp4" },
                { "type": "text",   "value": "Decided to add physics objects as the main interaction with the environment (using controlled sub-stepping and CCD to prevent chaos physics errors). The player can open doors by dragging them with the mouse and locking them if they're left softly in their start position. The player can also interact with weighted boxes; the heavier the object is, the more difficult it will be for the player to lift it. He can also jam the doors with them, and depending on the weight of the box, it will be harder or easier to move the door. There is also some balancer to compare weighted boxes and a pressure plate that works with them." }
            ]
        },
        {
            "name":     "UE Vite fork",
            "tags":     ["Programming", "Rendering"],
            "subtitle": "Rendering/c++ test · 2025",
            "large":    true,
            "thumb":    "./Assets/Media/uevcarddgi.png",
            "content": [
                { "type": "text",   "value": "This small test was focused on testing the ue4.27 vite fork, a fork made by the community with the objective to replace the new ue5 since this one has presented a lot of unfinished technologies which affect a lot in game performance and give the well-known 'unreal look' (one of the main reasons why all the games made in ue5 are being criticized)." },
                { "type": "text",   "value": "You can see more details about the Vite fork on its official GitHub repo: https://github.com/GapingPixel/UnrealEngineVite-PhysX" },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "md" },
                { "type": "text",   "value": "One of the technologies included in the UE4 Vite fork is DDGI (Dynamic Diffuse Global Illumination), a lightweight real-time GI solution based on a grid of light probes inside a volume. As its name suggests, it is fully dynamic and computes indirect diffuse lighting in world space (not screen space), allowing it to capture off-screen bounce lighting with a relatively low performance cost. A key advantage of this technique is that it operates through DDGI Volumes, which makes it possible to enable or disable GI per area or use different volume configurations depending on each zone of the game:" },
                { "type": "spacer", "size": "md" },
                { "type": "compare", "before": "./Assets/Media/uevcarnoddgi.png", "after": "./Assets/Media/uevcarddgi.png", "labelBefore": "DDGI", "labelAfter": "No DDGI" },
                { "type": "text",   "value": "Comparison of a basic environment with emmisive materials and reflecting surfaces using and not using DDGI running at ~170 fps." },
                { "type": "spacer", "size": "md" },
                { "type": "compare", "before": "./Assets/Media/noddgi.png", "after": "./Assets/Media/ddgi.png", "labelBefore": "DDGI", "labelAfter": "No DDGI" },
                { "type": "text",   "value": "Comparison now on a more complex environment using and not using DDGI running at ~125 fps." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "md" },
                { "type": "image",  "src": "./Assets/Media/uevconfig.png" },
                { "type": "text",   "value": "These are some of the DefualtEngine.ini configurations I used for those examples above:" },
                { "type": "text",   "value": "-Changed the 'tonemapper' gamma and disabled default auto exposure to get a brighter output and prevent the exposure from adjusting automatically." },
                { "type": "text",   "value": "-Changed volumetric lighting configs to get a better dynamic result." },
                { "type": "text",   "value": "-Disabled half-resolution screen space reflections since it doesn't affect a lot in performance and gives better results." },
                { "type": "text",   "value": "-Small quality configuration changes on SSR and AO." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "md" },
                { "type": "image",  "src": "./Assets/Media/charh.png" },
                { "type": "image",  "src": "./Assets/Media/charcpp.png" },
                { "type": "text",   "value": "This is part of the basic cpp character used in the project, it includes basic movement, interaction trace and configurations for the same movmement, it also calls a fuction whenever any of the actions are being executed (move, jump, crouch...) so you can get the signal in BP and do something with it, and you can also call these events from BP in case you wanna make the player jump, crouch or move individually." },
                { "type": "image",  "src": "./Assets/Media/charbp.png" }
            ]
        },
        {
            "name":     "Fiz's aquarium",
            "tags":     ["Programming"],
            "subtitle": "Interactive computer wallpaper · 2025",
            "large":    false,
            "thumb":    "./Assets/Media/fiz.png",
            "content": [
                { "type": "text",   "value": "This personal project I made is an interactive wallpaper (made completly for fun and to test my skills) where you can have multiple fish (customizable by user), each fish will have an individual behavior which includes swimming around the background (sea/aquarium) and sometimes jumping out of the water, each fish has a life bar, the user will be able to give them food, but if he doesn't, they will eventually die." },
                { "type": "text",   "value": "This have been made using Wallpaper Engine, which uses 'Scene Script', a fork of JS (Java script)." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/fiz01.mp4" },
                { "type": "text",   "value": "In this video you can see how the user is able to customize some specific parts of the wallpaper + the interactions the user has with it." },
                { "type": "spacer", "size": "md" },
                { "type": "video",  "src": "./Assets/Media/fiz02.mp4" },
                { "type": "text",   "value": "This one shows more of the fish movement, the life system and the full background art (made for max 3 screens width)." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "text",   "value": "The fish movement works by using private variables in its position: one for gravity and another for velocity. It also uses a random timer (based on runtime), and when that timer reaches 0, it adds a random X/Y value to the velocity to create the movement impulse. To make the fish slow down, the velocity is constantly multiplied by 0.75. Gravity always affects the Y position independently of the velocity. The gravity value changes depending on the state of the fish whether it is dead, outside the water, or inside the water." }

            ]
        },
        {
            "name":     "Idle game",
            "tags":     ["Programming", "Game design", "Rendering"],
            "subtitle": "Duo project · 2025",
            "large":    false,
            "thumb":    "./Assets/Media/rit.png",
            "content": [
                { "type": "text",   "value": "This project was meant to be a fast duo project made to support other projects of ours; at the end, we decided to stop working on it for the time-consuming it was, and so we could focus more on other main projects we had." },
                { "type": "text",   "value": "I was the responsible for the game design and half of the programming, also worked a little bit on the rendering to prepare everything for a big amount of actors + the isometric view." },
                { "type": "spacer", "size": "sm" },
                { "type": "divider"},
                { "type": "spacer", "size": "sm" },
                { "type": "video",  "src": "./Assets/Media/rit01.mp4" },
                { "type": "text",   "value": "Here you can see pretty much all the mechanics that were done at the moment. The game was planned to be a robot factory. You will have 3 different parts generators (head, body, and legs), each one with different sell prices. All the generators had a 50% chance of generating a bad-quality part (the red ones), and then you have the connector slot, which will need 3 different robot parts and will generate a whole robot with a higher sell price. Depending on how many bad-quality parts were used to make the robot, it will have higher or lower chances to generate a bad-quality robot. There are also the movement slots (conveyor belt and launch pads), basic part movers. There's also an unfinished upgrade system, which was meant to work to upgrade gen speed, quality chances, movement speed, and others. Each slot also has its life system, which decreases with the time it has been used. Here's where the drone slot begins being used: it basically repairs broken slots around it (upgradeable speed and range)." },
                { "type": "spacer", "size": "sm" },
                { "type": "text",   "value": "I was in charge of programming the camera system, part movement system, slots management (including upgrading the slots area), model animations (animated using timelines), and mostly fixing bugs on UIs, QoL, and slots functions." }            
            ]
        }
    ]
}